package com.efounder.sql;

import java.sql.*;


/**
 * <p>Title: </p>
 *
 * <p>Description: </p>
 *
 * <p>Copyright: Copyright (c) 2003</p>
 *
 * <p>Company: </p>
 *
 * @author not attributable
 * @version 1.0
 */
public class DelegateStatement implements Statement {
  protected Statement stmt = null;
  /**
   *
   * @return Statement
   */
  public Statement getImpStatement() {
    return stmt;
  }
  /**
   *
   */
  protected JConnection conn = null;
  /**
   *
   * @return JConnection
   */
  public JConnection getJConnection() {
    return conn;
  }
  /**
   *
   * @param stmt Statement
   * @return Statement
   */
  public static Statement getInstance(JConnection conn,Statement stmt) {
    return new DelegateStatement(conn,stmt);
  }
  /**
   *
   * @param stmt Statement
   */
  protected DelegateStatement(JConnection conn,Statement stmt) {
    this.stmt = stmt;
    this.conn = conn;
  }

  /**
   * Adds the given SQL command to the current list of commmands for this <code>Statement</code>
   * object.
   *
   * @param sql typically this is a static SQL <code>INSERT</code> or <code>UPDATE</code> statement
   * @throws SQLException if a database access error occurs, or the driver does not support batch
   *   updates
   * @todo Implement this java.sql.Statement method
   */
  public void addBatch(String sql) throws SQLException {
    conn.logInfo(sql,2);
    stmt.addBatch(sql);
  }

  /**
   * Cancels this <code>Statement</code> object if both the DBMS and driver support aborting an SQL
   * statement.
   *
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public void cancel() throws SQLException {
    stmt.cancel();
  }

  /**
   * Empties this <code>Statement</code> object's current list of SQL commands.
   *
   * @throws SQLException if a database access error occurs or the driver does not support batch
   *   updates
   * @todo Implement this java.sql.Statement method
   */
  public void clearBatch() throws SQLException {
    stmt.clearBatch();
  }

  /**
   * Clears all the warnings reported on this <code>Statement</code> object.
   *
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public void clearWarnings() throws SQLException {
    stmt.clearWarnings();
  }

  /**
   * Releases this <code>Statement</code> object's database and JDBC resources immediately instead
   * of waiting for this to happen when it is automatically closed.
   *
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public void close() throws SQLException {
    stmt.close();
  }

  /**
   * Executes the given SQL statement, which may return multiple results, and signals the driver
   * that any auto-generated keys should be made available for retrieval.
   *
   * @param sql any SQL statement
   * @param autoGeneratedKeys a constant indicating whether auto-generated keys should be made
   *   available for retrieval using the method <code>getGeneratedKeys</code>; one of the
   *   following constants: <code>Statement.RETURN_GENERATED_KEYS</code> or
   *   <code>Statement.NO_GENERATED_KEYS</code>
   * @return <code>true</code> if the first result is a <code>ResultSet</code> object;
   *   <code>false</code> if it is an update count or there are no results
   * @throws SQLException if a database access error occurs or the second parameter supplied to
   *   this method is not <code>Statement.RETURN_GENERATED_KEYS</code> or
   *   <code>Statement.NO_GENERATED_KEYS</code>.
   * @todo Implement this java.sql.Statement method
   */
  public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
    return stmt.execute(sql,autoGeneratedKeys);
  }

  /**
   * Executes the given SQL statement, which may return multiple results, and signals the driver
   * that the auto-generated keys indicated in the given array should be made available for
   * retrieval.
   *
   * @param sql any SQL statement
   * @param columnNames an array of the names of the columns in the inserted row that should be
   *   made available for retrieval by a call to the method <code>getGeneratedKeys</code>
   * @return <code>true</code> if the next result is a <code>ResultSet</code> object;
   *   <code>false</code> if it is an update count or there are no more results
   * @throws SQLException if a database access error occurs or the elements of the
   *   <code>String</code> array passed to this method are not valid column names
   * @todo Implement this java.sql.Statement method
   */
  public boolean execute(String sql, String[] columnNames) throws SQLException {
    return stmt.execute(sql,columnNames);
  }

  /**
   * Executes the given SQL statement, which may return multiple results, and signals the driver
   * that the auto-generated keys indicated in the given array should be made available for
   * retrieval.
   *
   * @param sql any SQL statement
   * @param columnIndexes an array of the indexes of the columns in the inserted row that should
   *   be made available for retrieval by a call to the method <code>getGeneratedKeys</code>
   * @return <code>true</code> if the first result is a <code>ResultSet</code> object;
   *   <code>false</code> if it is an update count or there are no results
   * @throws SQLException if a database access error occurs or the elements in the
   *   <code>int</code> array passed to this method are not valid column indexes
   * @todo Implement this java.sql.Statement method
   */
  public boolean execute(String sql, int[] columnIndexes) throws SQLException {
    return stmt.execute(sql,columnIndexes);
  }

  /**
   * Executes the given SQL statement, which may return multiple results.
   *
   * @param sql any SQL statement
   * @return <code>true</code> if the first result is a <code>ResultSet</code> object;
   *   <code>false</code> if it is an update count or there are no results
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public boolean execute(String sql) throws SQLException {
   long t1 = System.currentTimeMillis();
   try {
     return stmt.execute(sql);
   }
   finally {
     long t2 = System.currentTimeMillis();
     if (conn != null)
       conn.logInfo(sql+" execute time:" + (t2 - t1), 2);
   }
  }

  /**
   * Submits a batch of commands to the database for execution and if all commands execute
   * successfully, returns an array of update counts.
   *
   * @return an array of update counts containing one element for each command in the batch. The
   *   elements of the array are ordered according to the order in which commands were added to
   *   the batch.
   * @throws SQLException if a database access error occurs or the driver does not support batch
   *   statements. Throws {@link BatchUpdateException} (a subclass of <code>SQLException</code>)
   *   if one of the commands sent to the database fails to execute properly or attempts to return
   *   a result set.
   * @todo Implement this java.sql.Statement method
   */
  public int[] executeBatch() throws SQLException {
    long t1 = System.currentTimeMillis();
   try {
   return stmt.executeBatch();
   }
   finally {
     long t2 = System.currentTimeMillis();
     if (conn != null)
       conn.logInfo("batch execute time:" + (t2 - t1), 1);
   }


  }

  /**
   * Executes the given SQL statement, which returns a single <code>ResultSet</code> object.
   *
   * @param sql an SQL statement to be sent to the database, typically a static SQL
   *   <code>SELECT</code> statement
   * @return a <code>ResultSet</code> object that contains the data produced by the given query;
   *   never <code>null</code>
   * @throws SQLException if a database access error occurs or the given SQL statement produces
   *   anything other than a single <code>ResultSet</code> object
   * @todo Implement this java.sql.Statement method
   */
  public ResultSet executeQuery(String sql) throws SQLException {
    long t1 = System.currentTimeMillis();
     try {
     return stmt.executeQuery(sql);
     }
     finally {
       long t2 = System.currentTimeMillis();
       if (conn != null)
         conn.logInfo(sql+ "execute time:" + (t2 - t1), 1);
     }


  }

  /**
   * Executes the given SQL statement, which may be an <code>INSERT</code>, <code>UPDATE</code>, or
   * <code>DELETE</code> statement or an SQL statement that returns nothing, such as an SQL DDL
   * statement.
   *
   * @param sql an SQL <code>INSERT</code>, <code>UPDATE</code> or <code>DELETE</code> statement
   *   or an SQL statement that returns nothing
   * @return either the row count for <code>INSERT</code>, <code>UPDATE</code> or
   *   <code>DELETE</code> statements, or <code>0</code> for SQL statements that return nothing
   * @throws SQLException if a database access error occurs or the given SQL statement produces a
   *   <code>ResultSet</code> object
   * @todo Implement this java.sql.Statement method
   */

  public int executeUpdate(String sql) throws SQLException {
    long t1 = System.currentTimeMillis();
    try {
      return stmt.executeUpdate(sql);
    }
    finally {
      long t2 = System.currentTimeMillis();
      if (conn != null)
        conn.logInfo(sql+ "execute time:" + (t2 - t1), 2);
    }


  }

  /**
   * Executes the given SQL statement and signals the driver with the given flag about whether the
   * auto-generated keys produced by this <code>Statement</code> object should be made available
   * for retrieval.
   *
   * @param sql must be an SQL <code>INSERT</code>, <code>UPDATE</code> or <code>DELETE</code>
   *   statement or an SQL statement that returns nothing
   * @param autoGeneratedKeys a flag indicating whether auto-generated keys should be made
   *   available for retrieval; one of the following constants:
   *   <code>Statement.RETURN_GENERATED_KEYS</code> <code>Statement.NO_GENERATED_KEYS</code>
   * @return either the row count for <code>INSERT</code>, <code>UPDATE</code> or
   *   <code>DELETE</code> statements, or <code>0</code> for SQL statements that return nothing
   * @throws SQLException if a database access error occurs, the given SQL statement returns a
   *   <code>ResultSet</code> object, or the given constant is not one of those allowed
   * @todo Implement this java.sql.Statement method
   */
  public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
    return stmt.executeUpdate(sql,autoGeneratedKeys);
  }

  /**
   * Executes the given SQL statement and signals the driver that the auto-generated keys indicated
   * in the given array should be made available for retrieval.
   *
   * @param sql an SQL <code>INSERT</code>, <code>UPDATE</code> or <code>DELETE</code> statement
   *   or an SQL statement that returns nothing
   * @param columnNames an array of the names of the columns that should be returned from the
   *   inserted row
   * @return either the row count for <code>INSERT</code>, <code>UPDATE</code>, or
   *   <code>DELETE</code> statements, or 0 for SQL statements that return nothing
   * @throws SQLException if a database access error occurs, the SQL statement returns a
   *   <code>ResultSet</code> object, or the second argument supplied to this method is not a
   *   <code>String</code> array whose elements are valid column names
   * @todo Implement this java.sql.Statement method
   */
  public int executeUpdate(String sql, String[] columnNames) throws SQLException {
    return stmt.executeUpdate(sql,columnNames);
  }

  /**
   * Executes the given SQL statement and signals the driver that the auto-generated keys indicated
   * in the given array should be made available for retrieval.
   *
   * @param sql an SQL <code>INSERT</code>, <code>UPDATE</code> or <code>DELETE</code> statement
   *   or an SQL statement that returns nothing, such as an SQL DDL statement
   * @param columnIndexes an array of column indexes indicating the columns that should be
   *   returned from the inserted row
   * @return either the row count for <code>INSERT</code>, <code>UPDATE</code>, or
   *   <code>DELETE</code> statements, or 0 for SQL statements that return nothing
   * @throws SQLException if a database access error occurs, the SQL statement returns a
   *   <code>ResultSet</code> object, or the second argument supplied to this method is not an
   *   <code>int</code> array whose elements are valid column indexes
   * @todo Implement this java.sql.Statement method
   */
  public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
    return stmt.executeUpdate(sql,columnIndexes);
  }

  /**
   * Retrieves the <code>Connection</code> object that produced this <code>Statement</code> object.
   *
   * @return the connection that produced this statement
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public Connection getConnection() throws SQLException {
    return stmt.getConnection();
  }

  /**
   * Retrieves the direction for fetching rows from database tables that is the default for result
   * sets generated from this <code>Statement</code> object.
   *
   * @return the default fetch direction for result sets generated from this
   *   <code>Statement</code> object
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public int getFetchDirection() throws SQLException {
    return stmt.getFetchDirection();
  }

  /**
   * Retrieves the number of result set rows that is the default fetch size for
   * <code>ResultSet</code> objects generated from this <code>Statement</code> object.
   *
   * @return the default fetch size for result sets generated from this <code>Statement</code>
   *   object
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public int getFetchSize() throws SQLException {
    return stmt.getFetchSize();
  }

  /**
   * Retrieves any auto-generated keys created as a result of executing this <code>Statement</code>
   * object.
   *
   * @return a <code>ResultSet</code> object containing the auto-generated key(s) generated by the
   *   execution of this <code>Statement</code> object
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public ResultSet getGeneratedKeys() throws SQLException {
    return stmt.getGeneratedKeys();
  }

  /**
   * Retrieves the maximum number of bytes that can be returned for character and binary column
   * values in a <code>ResultSet</code> object produced by this <code>Statement</code> object.
   *
   * @return the current column size limit for columns storing character and binary values; zero
   *   means there is no limit
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public int getMaxFieldSize() throws SQLException {
    return stmt.getMaxFieldSize();
  }

  /**
   * Retrieves the maximum number of rows that a <code>ResultSet</code> object produced by this
   * <code>Statement</code> object can contain.
   *
   * @return the current maximum number of rows for a <code>ResultSet</code> object produced by
   *   this <code>Statement</code> object; zero means there is no limit
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public int getMaxRows() throws SQLException {
    return stmt.getMaxRows();
  }

  /**
   * Moves to this <code>Statement</code> object's next result, returns <code>true</code> if it is
   * a <code>ResultSet</code> object, and implicitly closes any current <code>ResultSet</code>
   * object(s) obtained with the method <code>getResultSet</code>.
   *
   * @return <code>true</code> if the next result is a <code>ResultSet</code> object;
   *   <code>false</code> if it is an update count or there are no more results
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public boolean getMoreResults() throws SQLException {
    return stmt.getMoreResults();
  }

  /**
   * Moves to this <code>Statement</code> object's next result, deals with any current
   * <code>ResultSet</code> object(s) according to the instructions specified by the given flag,
   * and returns <code>true</code> if the next result is a <code>ResultSet</code> object.
   *
   * @param current one of the following <code>Statement</code> constants indicating what should
   *   happen to current <code>ResultSet</code> objects obtained using the method
   *   <code>getResultSet</code>: <code>Statement.CLOSE_CURRENT_RESULT</code>,
   *   <code>Statement.KEEP_CURRENT_RESULT</code>, or <code>Statement.CLOSE_ALL_RESULTS</code>
   * @return <code>true</code> if the next result is a <code>ResultSet</code> object;
   *   <code>false</code> if it is an update count or there are no more results
   * @throws SQLException if a database access error occurs or the argument supplied is not one of
   *   the following: <code>Statement.CLOSE_CURRENT_RESULT</code>,
   *   <code>Statement.KEEP_CURRENT_RESULT</code>, or <code>Statement.CLOSE_ALL_RESULTS</code>
   * @todo Implement this java.sql.Statement method
   */
  public boolean getMoreResults(int current) throws SQLException {
    return stmt.getMoreResults(current);
  }

  /**
   * Retrieves the number of seconds the driver will wait for a <code>Statement</code> object to
   * execute.
   *
   * @return the current query timeout limit in seconds; zero means there is no limit
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public int getQueryTimeout() throws SQLException {
    return stmt.getQueryTimeout();
  }

  /**
   * Retrieves the current result as a <code>ResultSet</code> object.
   *
   * @return the current result as a <code>ResultSet</code> object or <code>null</code> if the
   *   result is an update count or there are no more results
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public ResultSet getResultSet() throws SQLException {
    return stmt.getResultSet();
  }

  /**
   * Retrieves the result set concurrency for <code>ResultSet</code> objects generated by this
   * <code>Statement</code> object.
   *
   * @return either <code>ResultSet.CONCUR_READ_ONLY</code> or
   *   <code>ResultSet.CONCUR_UPDATABLE</code>
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public int getResultSetConcurrency() throws SQLException {
    return stmt.getResultSetConcurrency();
  }

  /**
   * Retrieves the result set holdability for <code>ResultSet</code> objects generated by this
   * <code>Statement</code> object.
   *
   * @return either <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or
   *   <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public int getResultSetHoldability() throws SQLException {
    return stmt.getResultSetHoldability();
  }

  /**
   * Retrieves the result set type for <code>ResultSet</code> objects generated by this
   * <code>Statement</code> object.
   *
   * @return one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
   *   <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or
   *   <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public int getResultSetType() throws SQLException {
    return stmt.getResultSetType();
  }

  /**
   * Retrieves the current result as an update count; if the result is a <code>ResultSet</code>
   * object or there are no more results, -1 is returned.
   *
   * @return the current result as an update count; -1 if the current result is a
   *   <code>ResultSet</code> object or there are no more results
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public int getUpdateCount() throws SQLException {
    return stmt.getUpdateCount();
  }

  /**
   * Retrieves the first warning reported by calls on this <code>Statement</code> object.
   *
   * @return the first <code>SQLWarning</code> object or <code>null</code> if there are no warnings
   * @throws SQLException if a database access error occurs or this method is called on a closed
   *   statement
   * @todo Implement this java.sql.Statement method
   */
  public SQLWarning getWarnings() throws SQLException {
    return stmt.getWarnings();
  }

  /**
   * Sets the SQL cursor name to the given <code>String</code>, which will be used by subsequent
   * <code>Statement</code> object <code>execute</code> methods.
   *
   * @param name the new cursor name, which must be unique within a connection
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public void setCursorName(String name) throws SQLException {
    stmt.setCursorName(name);
  }

  /**
   * Sets escape processing on or off.
   *
   * @param enable <code>true</code> to enable escape processing; <code>false</code> to disable it
   * @throws SQLException if a database access error occurs
   * @todo Implement this java.sql.Statement method
   */
  public void setEscapeProcessing(boolean enable) throws SQLException {
    stmt.setEscapeProcessing(enable);
  }

  /**
   * Gives the driver a hint as to the direction in which rows will be processed in
   * <code>ResultSet</code> objects created using this <code>Statement</code> object.
   *
   * @param direction the initial direction for processing rows
   * @throws SQLException if a database access error occurs or the given direction is not one of
   *   <code>ResultSet.FETCH_FORWARD</code>, <code>ResultSet.FETCH_REVERSE</code>, or
   *   <code>ResultSet.FETCH_UNKNOWN</code>
   * @todo Implement this java.sql.Statement method
   */
  public void setFetchDirection(int direction) throws SQLException {
    stmt.setFetchDirection(direction);
  }

  /**
   * Gives the JDBC driver a hint as to the number of rows that should be fetched from the database
   * when more rows are needed.
   *
   * @param rows the number of rows to fetch
   * @throws SQLException if a database access error occurs, or the condition 0 <=
   *   <code>rows</code> <= <code>this.getMaxRows()</code> is not satisfied.
   * @todo Implement this java.sql.Statement method
   */
  public void setFetchSize(int rows) throws SQLException {
    stmt.setFetchSize(rows);
  }

  /**
   * Sets the limit for the maximum number of bytes in a <code>ResultSet</code> column storing
   * character or binary values to the given number of bytes.
   *
   * @param max the new column size limit in bytes; zero means there is no limit
   * @throws SQLException if a database access error occurs or the condition max >= 0 is not
   *   satisfied
   * @todo Implement this java.sql.Statement method
   */
  public void setMaxFieldSize(int max) throws SQLException {
    stmt.setMaxFieldSize(max);
  }

  /**
   * Sets the limit for the maximum number of rows that any <code>ResultSet</code> object can
   * contain to the given number.
   *
   * @param max the new max rows limit; zero means there is no limit
   * @throws SQLException if a database access error occurs or the condition max >= 0 is not
   *   satisfied
   * @todo Implement this java.sql.Statement method
   */
  public void setMaxRows(int max) throws SQLException {
    stmt.setMaxRows(max);
  }

  /**
   * Sets the number of seconds the driver will wait for a <code>Statement</code> object to execute
   * to the given number of seconds.
   *
   * @param seconds the new query timeout limit in seconds; zero means there is no limit
   * @throws SQLException if a database access error occurs or the condition seconds >= 0 is not
   *   satisfied
   * @todo Implement this java.sql.Statement method
   */
  public void setQueryTimeout(int seconds) throws SQLException {
    stmt.setQueryTimeout(seconds);
  }
@Override
public boolean isClosed() throws SQLException {
	// TODO Auto-generated method stub
	return false;
}
@Override
public boolean isPoolable() throws SQLException {
	// TODO Auto-generated method stub
	return false;
}
@Override
public void setPoolable(boolean poolable) throws SQLException {
	// TODO Auto-generated method stub
	
}
@Override
public boolean isWrapperFor(Class<?> iface) throws SQLException {
	// TODO Auto-generated method stub
	return false;
}
@Override
public <T> T unwrap(Class<T> iface) throws SQLException {
	// TODO Auto-generated method stub
	return null;
}
}
